#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
根据 docs/specs/functional_spec.json 自动生成：
1) FastAPI 路由占位实现：backend/api/generated.py
2) 前端占位页面：frontend/pages/generated/*.html（每个模块一个页面 + index）

后端规则：
- 若 inputs 为空 -> 生成 GET 路由；否则 -> 生成 POST 路由
- 路径按 spec 的 api 字段，自动去重（相同 method+path 仅生成一次）
- GET 读取 query 参数；POST 接收 JSON body（payload: dict）
- 返回统一结构：{"code": 0, "endpoint": path, "method": method, "received": {...}}

前端规则：
- 生成 /generated/index.html：列出所有模块并链接
- 生成 /generated/<module_key>.html：
    - 展示模块名、每个功能的卡片
    - inputs 为空 -> GET 按钮直接调用；否则 -> POST，动态收集表单字段
    - 结果以 JSON 美化展示
"""

import json
from pathlib import Path
from typing import Dict, List, Tuple, Any

ROOT = Path(__file__).resolve().parents[1]
SPEC_PATH = ROOT / "docs/specs/functional_spec.json"
OUT_PATH = ROOT / "backend/api/generated.py"
FRONT_GEN_DIR = ROOT / "frontend/pages/generated"

HEADER = """# Auto-generated by scripts/gen_from_spec.py; DO NOT EDIT MANUALLY
from typing import Any, Dict, Optional
from fastapi import APIRouter, Request, UploadFile, File, Form

router = APIRouter()

"""

TEMPLATE_GET = """
@router.get("{path}")
async def get_{fname}(request: Request):
    params = dict(request.query_params)
    return {{"code": 0, "endpoint": "{path}", "method": "GET", "received": params}}
"""

TEMPLATE_POST_JSON = """
@router.post("{path}")
async def post_{fname}(payload: Dict[str, Any]):
    return {{"code": 0, "endpoint": "{path}", "method": "POST", "received": payload}}
"""

TEMPLATE_POST_FORM = """
@router.post("{path}")
async def post_{fname}({params_signature}):
    received: Dict[str, Any] = {{}}
{params_assign}
    return {{"code": 0, "endpoint": "{path}", "method": "POST", "received": received}}
"""

def safe_func_name(path: str, method: str) -> str:
    # /api/foo/bar -> api_foo_bar ; 加上方法以避免重名
    base = path.strip("/").replace("/", "_").replace("-", "_")
    if not base:
        base = "root"
    return f"{method.lower()}__{base}"


def load_spec() -> Dict:
    with SPEC_PATH.open("r", encoding="utf-8") as f:
        return json.load(f)


def normalize_inputs(inputs: List[Any]) -> List[Dict[str, str]]:
    norm: List[Dict[str, str]] = []
    for it in inputs or []:
        if isinstance(it, str):
            norm.append({"name": it, "type": "string"})
        elif isinstance(it, dict):
            name = it.get("name") or it.get("key") or it.get("id")
            typ = (it.get("type") or it.get("inputType") or "string").lower()
            if name:
                norm.append({"name": str(name), "type": str(typ)})
    return norm


def decide_method(inputs: List[Any]) -> str:
    return "GET" if not inputs else "POST"


def generate_backend(spec: Dict) -> int:
    seen: set[Tuple[str, str]] = set()  # (method, path)
    pieces: List[str] = [HEADER]

    modules = spec.get("modules", [])
    for m in modules:
        funcs = m.get("functions", [])
        for fn in funcs:
            path = fn.get("api")
            inputs_raw = fn.get("inputs", [])
            if not path or not isinstance(path, str):
                continue
            method = decide_method(inputs_raw)
            key = (method, path)
            if key in seen:
                continue
            seen.add(key)
            fname = safe_func_name(path, method)
            if method == "GET":
                pieces.append(TEMPLATE_GET.format(path=path, fname=fname))
            else:
                norm_inputs = normalize_inputs(inputs_raw)
                has_file = any(i.get("type") in {"file", "image", "binary"} for i in norm_inputs)
                if has_file:
                    # Build FastAPI signature with UploadFile / Form
                    sig_parts: List[str] = []
                    assigns: List[str] = []
                    for i in norm_inputs:
                        name = i["name"].replace("-", "_")
                        typ = i["type"]
                        if typ in {"file", "image", "binary"}:
                            sig_parts.append(f"{name}: Optional[UploadFile] = File(None)")
                            assigns.append(f"    if {name} is not None:\n        received['{i['name']}'] = {{'filename': {name}.filename, 'content_type': {name}.content_type}}")
                        else:
                            sig_parts.append(f"{name}: Optional[str] = Form(None)")
                            assigns.append(f"    received['{i['name']}'] = {name}")
                    pieces.append(TEMPLATE_POST_FORM.format(path=path, fname=fname, params_signature=", ".join(sig_parts), params_assign="\n".join(assigns)))
                else:
                    pieces.append(TEMPLATE_POST_JSON.format(path=path, fname=fname))

    content = "\n".join(pieces).strip() + "\n"
    OUT_PATH.parent.mkdir(parents=True, exist_ok=True)
    OUT_PATH.write_text(content, encoding="utf-8")
    print(f"Generated {OUT_PATH} with {len(seen)} endpoints.")
    return len(seen)

HTML_INDEX_HEAD = """<!DOCTYPE html>
<html lang=\"zh-CN\">
<head>
    <meta charset=\"utf-8\" />
    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />
    <title>自动生成模块</title>
    <link rel=\"stylesheet\" href=\"/static/css/generated.css\" />
</head>
<body>
    <h1>自动生成模块目录</h1>
    <div class=\"grid\">
"""

HTML_INDEX_TAIL = """
  </div>
    <p style=\"margin-top:24px\"><a href=\"/pages/index.html\">返回首页</a></p>
</body>
</html>
"""

HTML_MODULE_HEAD = """<!DOCTYPE html>
<html lang=\"zh-CN\">
<head>
    <meta charset=\"utf-8\" />
    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />
    <title>{title}</title>
    <link rel=\"stylesheet\" href=\"/static/css/generated.css\" />
    <script defer src=\"/static/js/generated.js\"></script>
</head>
<body>
    <h1>{module_name}</h1>
    <p class=\"meta\">模块键：{module_key}</p>
    <p><a href=\"/pages/generated/index.html\">返回模块目录</a></p>
"""

HTML_MODULE_TAIL = """
    <p style=\"margin-top:24px\"><a href=\"/pages/index.html\">返回首页</a></p>
</body>
</html>
"""

def safe_id(text: str) -> str:
    return text.strip().replace("/", "_").replace("-", "_").replace(" ", "_")

def render_module_page(module_name: str, module_key: str, funcs: List[Dict]) -> str:
    parts: List[str] = [HTML_MODULE_HEAD.format(title=module_name, module_name=module_name, module_key=module_key)]
    for i, fn in enumerate(funcs, start=1):
        path = fn.get("api", "")
        inputs_raw = fn.get("inputs", []) or []
        norm_inputs = normalize_inputs(inputs_raw)
        method = "GET" if not norm_inputs else "POST"
        has_file = any(inp.get("type") in {"file", "image", "binary"} for inp in norm_inputs)
        fname = safe_id(f"{module_key}_{i}")
        encode_attr = " data-encode=\"multipart\"" if has_file else ""
        parts.append(f"<div class=\"fn\" id=\"{fname}\"{encode_attr}>")
        parts.append(f"  <h3>{fn.get('name','未命名')}</h3>\n  <div class=\"meta\">{method} {path}</div>")
        if norm_inputs:
            parts.append("  <div class=\"row\">")
            for inp in norm_inputs:
                in_name = inp.get("name", "field")
                in_type = inp.get("type", "string").lower()
                html_type = "file" if in_type in {"file", "image", "binary"} else ("number" if in_type in {"number", "int", "float"} else "text")
                parts.append(
                    f"    <label>{in_name}<input data-input=\\\"{in_name}\\\" type=\\\"{html_type}\\\" placeholder=\\\"{in_name}\\\" /></label>"
                )
            parts.append("  </div>")
        parts.append(f"  <div class=\\\"actions\\\"><button class=\\\"call-btn\\\" data-method=\\\"{method}\\\" data-path=\\\"{path}\\\">执行</button></div>")
        parts.append(f"  <pre class=\\\"out\\\" id=\\\"{fname}__out\\\"></pre>")
        parts.append("</div>")
    parts.append(HTML_MODULE_TAIL)
    return "\n".join(parts)

def generate_frontend(spec: Dict) -> int:
    FRONT_GEN_DIR.mkdir(parents=True, exist_ok=True)
    modules = spec.get("modules", [])
    index_parts = [HTML_INDEX_HEAD]
    for m in modules:
        name = m.get("module", "未命名模块")
        key = m.get("key", safe_id(name))
        index_parts.append(f"  <div class=\\\"card\\\"><h3><a href=\\\"/pages/generated/{key}.html\\\">{name}</a></h3><div class=\\\"meta\\\">{key}</div></div>")
    index_parts.append(HTML_INDEX_TAIL)
    (FRONT_GEN_DIR / "index.html").write_text("\n".join(index_parts), encoding="utf-8")

    count_pages = 0
    for m in modules:
        name = m.get("module", "未命名模块")
        key = m.get("key", safe_id(name))
        funcs = m.get("functions", [])
        html = render_module_page(name, key, funcs)
        (FRONT_GEN_DIR / f"{key}.html").write_text(html, encoding="utf-8")
        count_pages += 1
    print(f"Generated frontend pages at {FRONT_GEN_DIR} for {count_pages} modules.")
    return count_pages

def generate() -> None:
    spec = load_spec()
    n_api = generate_backend(spec)
    n_pages = generate_frontend(spec)
    print(f"Done. API endpoints: {n_api}, Pages: {n_pages}")


if __name__ == "__main__":
    generate()
